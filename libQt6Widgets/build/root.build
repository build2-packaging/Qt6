using in

cxx.std = latest

using cxx

hxx{*}: extension = h
cxx{*}: extension = cpp

# Assume headers are importable unless stated otherwise.
#
hxx{*}: cxx.importable = true

using cxx.objcxx

# If true, build without -DQT_NO_DEBUG.
#
config [bool] config.libQt6Widgets.debug ?= false

linux   = ($cxx.target.class == 'linux')
bsd     = ($cxx.target.class == 'bsd')
windows = ($cxx.target.class == 'windows')
macos   = ($cxx.target.class  == 'macos')

if ($build.mode != 'skeleton')
{
  # Path to libQt6Core's moc_predefs.h header.
  #
  import! [metadata, rule_hint=cxx.link] corelib = libQt6Core%lib{Qt6CorePrivate}
  moc_predefs_path = $($corelib: libQt6Core.moc_predefs_path)

  # Define the .moc file type (C++ source file generated by moc from a C++
  # source file).
  #
  define moc: cxx
  moc{*}: extension = moc

  import! [metadata] moc = Qt6Moc%exe{qt6moc}

  # Rule to run moc on a header file (foo.h -> moc_foo.cpp).
  #
  # Use -f to override the path moc uses to #include the input file, which is
  # relative to the output directory, with just the name of the input file.
  #
  # Also add the exported search directories for Qt dependencies' headers (via
  # libul{*Meta}, declared as appropriate in the various buildfiles) because
  # some code will be skipped by MOC unless certain Qt features are enabled.
  #
  # Pass --no-notes to suppress "No relevant classes found. No output
  # generated" messages.
  #
  cxx{~'/moc_(.+)/'}: hxx{~'/\1/'} libul{~'/.+Meta/'} $moc
  {{
    o = $path($>[0])
    t = $(o).t

    dep_incl = $cxx.lib_poptions($<[1])

    depdb hash $dep_incl

    # Note: exclude libul{*Meta} from update during match not to mess up its
    #       for-install'ness.
    #
    depdb dyndep                                                \
      --byproduct --drop-cycles --what=header --default-type=h  \
      --update-exclude ($<[1])                                  \
      --file $t

    s = $path($<[0])

    sys_incl = $regex.apply($cxx.sys_hdr_dirs, '(.+)', '-I\1')

    $moc --no-notes                                     \
         --include $moc_predefs_path                    \
         $cc.poptions $cxx.poptions $dep_incl $sys_incl \
         -f $leaf($s) --output-dep-file --dep-file-path $t -o $o $s
  }}

  # Rule to run moc on a source file (foo.cpp -> foo.moc).
  #
  moc{~'/(.+)/'}: cxx{~'/\1/'} libul{~'/.+Meta/'} $moc
  {{
    o = $path($>[0])
    t = $(o).t

    dep_incl = $cxx.lib_poptions($<[1])

    depdb hash $dep_incl

    depdb dyndep                                                \
      --byproduct --drop-cycles --what=header --default-type=h  \
      --update-exclude ($<[1])                                  \
      --file $t

    s = $path($<[0])

    sys_incl = $regex.apply($cxx.sys_hdr_dirs, '(.+)', '-I\1')

    $moc --no-notes                                     \
         --include $moc_predefs_path                    \
         $cc.poptions $cxx.poptions $dep_incl $sys_incl \
         --output-dep-file --dep-file-path $t -o $o $s
  }}

  # Rule to run moc on an Objective-C++ source file (foo.mm -> foo.moc).
  #
  moc{~'/(.+)/'}: mm{~'/\1/'} libul{~'/.+Meta/'} $moc
  {{
    o = $path($>[0])
    t = $(o).t

    dep_incl = $cxx.lib_poptions($<[1])

    depdb hash $dep_incl

    depdb dyndep                                                \
      --byproduct --drop-cycles --what=header --default-type=h  \
      --update-exclude ($<[1])                                  \
      --file $t

    s = $path($<[0])

    sys_incl = $regex.apply($cxx.sys_hdr_dirs, '(.+)', '-I\1')

    $moc --no-notes                                     \
         --include $moc_predefs_path                    \
         $cc.poptions $cxx.poptions $dep_incl $sys_incl \
         --output-dep-file --dep-file-path $t -o $o $s
  }}

  # Define the Qt resource collection file type.
  #
  define qrc: file
  qrc{*}: extension = qrc

  import! [metadata] rcc = Qt6Rcc%exe{qt6rcc}

  # Rule to run rcc on a Qt resource collection file (foo.qrc -> qrc_foo.cpp).
  #
  # Extract the dependencies of the .qrc file on the resource files it
  # declares using rcc's --depfile option.
  #
  cxx{~'/qrc_(.*)/'}: qrc{~'/.*\1/'} $rcc
  {{
    o = $path($>[0])
    t = $(o).t

    depdb dyndep --byproduct --file $t

    $rcc -name $name($<[0]) --depfile $t -o $path($>[0]) $path($<[0])
  }}

  # Define the QtWidgets user interface definition file type.
  #
  define ui: file
  ui{*}: extension = ui

  import! [metadata] uic = Qt6Uic%exe{qt6uic}

  # Rule to run uic on a QtWidgets user interface definition file (foo.ui ->
  # ui_foo.h).
  #
  hxx{~'/ui_(.*)/'}: ui{~'/.*\1/'} $uic
  {{
    $uic -o $path($>[0]) $path($<[0])
  }}

  if! $config.libQt6Widgets.debug
    cxx.poptions += -DQT_NO_DEBUG

  # Every directory under mkspecs/ contains a unique `qplatformdefs.h`.
  #
  # Note that Mac OS with GCC is not supported by upstream (see README-DEV for
  # details).
  #
  switch $cxx.target.class, $cxx.id, $cxx.target.system
  {
    case 'linux', 'gcc'
      cxx.poptions =+ "-I$src_root/mkspecs/linux-g++"
    case 'linux', 'clang'
      cxx.poptions =+ "-I$src_root/mkspecs/linux-clang"
    case 'macos', 'clang-apple'
      cxx.poptions =+ "-I$src_root/mkspecs/macx-clang"
    case 'bsd', 'clang', 'freebsd'
      cxx.poptions =+ "-I$src_root/mkspecs/freebsd-clang"
    case 'bsd', 'gcc', 'openbsd'
      cxx.poptions =+ "-I$src_root/mkspecs/openbsd-g++"
    case 'bsd', 'gcc', 'netbsd'
      cxx.poptions =+ "-I$src_root/mkspecs/netbsd-g++"
    case 'windows', 'msvc'
      cxx.poptions =+ "-I$src_root/mkspecs/win32-msvc"
    case 'windows', 'msvc-clang' | 'clang'
      cxx.poptions =+ "-I$src_root/mkspecs/win32-clang-msvc"
    case 'windows', 'gcc', 'mingw32'
    {
      cxx.poptions =+ "-I$src_root/mkspecs/win32-g++"
      cxx.coptions += -fno-keep-inline-dllexport
    }
  }

  # Disable exceptions.
  #
  switch $cxx.class
  {
    case 'gcc'
    {
      cxx.poptions += -DQT_NO_EXCEPTIONS
      cxx.coptions += -fno-exceptions
    }
    case 'msvc'
    {
      cxx.poptions += -DQT_NO_EXCEPTIONS
      cxx.coptions += /EHs- /EHc-
    }
  }

  # Don't install headers in mkspecs/ (which is at the root level and is shared
  # between QtWidgets/ and QtWidgetsPlugins/).
  #
  hxx{mkspecs/*}: install = false

  # Common options, etc., for all the plugins.
  #
  QtWidgetsPlugins/
  {
    if ($cxx.class == 'gcc')
      cxx.coptions += -fvisibility=hidden -fvisibility-inlines-hidden

    # Don't install any plugin headers (for static linking the API is presumably
    # declared by the Qt plugin infrastructure).
    #
    hxx{*}: install = false
  }

  source build/common.build

} # $build.mode != 'skeleton'
