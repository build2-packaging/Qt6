using in

cxx.std = latest

using cxx

hxx{*}: extension = h
cxx{*}: extension = cpp

# Assume headers are importable unless stated otherwise.
#
hxx{*}: cxx.importable = true

using cxx.objcxx

# If true, build without -DQT_NO_DEBUG.
#
config [bool] config.libQt6Widgets.debug ?= false

linux   = ($cxx.target.class == 'linux')
bsd     = ($cxx.target.class == 'bsd')
windows = ($cxx.target.class == 'windows')
macos   = ($cxx.target.class  == 'macos')

if ($build.mode != 'skeleton')
{
  # Path to libQt6Core's moc_predefs.h header.
  #
  import! [metadata, rule_hint=cxx.link] corelib = libQt6Core%lib{Qt6CorePrivate}
  moc_predefs_path = $($corelib: libQt6Core.moc_predefs_path)

  # Define the .moc file type (C++ source file generated by moc from a C++
  # source file).
  #
  define moc: cxx
  moc{*}: extension = moc

  import! [metadata] moc = Qt6Moc%exe{qt6moc}

  # Rule to run moc on a header file (foo.h -> moc_foo.cpp).
  #
  # Use -f to override the path moc uses to #include the input file, which is
  # relative to the output directory, with just the name of the input file.
  #
  # Also add the exported search directories for Qt dependencies' headers (via
  # libul{*Meta}, declared as appropriate in the various buildfiles) because
  # some code will be skipped by MOC unless certain Qt features are enabled.
  #
  cxx{~'/moc_(.+)/'}: hxx{~'/\1/'} libul{~'/.+Meta/'} $moc
  {{
    o = $path($>[0])
    t = $(o).t

    dep_incl = $cxx.lib_poptions($<[1])

    depdb hash $dep_incl

    # Note: exclude libul{*Meta} from update during match not to mess up its
    #       for-install'ness.
    #
    depdb dyndep                                                \
      --byproduct --drop-cycles --what=header --default-type=h  \
      --update-exclude ($<[1])                                  \
      --file $t

    s = $path($<[0])

    sys_incl = $regex.apply($cxx.sys_hdr_dirs, '(.+)', '-I\1')

    $moc --include $moc_predefs_path                    \
      $cc.poptions $cxx.poptions $dep_incl $sys_incl    \
      -f $leaf($s) --output-dep-file --dep-file-path $t -o $o $s
  }}

  # Rule to run moc on a source file (foo.cpp -> foo.moc).
  #
  moc{~'/(.+)/'}: cxx{~'/\1/'} libul{~'/.+Meta/'} $moc
  {{
    o = $path($>[0])
    t = $(o).t

    dep_incl = $cxx.lib_poptions($<[1])

    depdb hash $dep_incl

    depdb dyndep                                                \
      --byproduct --drop-cycles --what=header --default-type=h  \
      --update-exclude ($<[1])                                  \
      --file $t

    s = $path($<[0])

    sys_incl = $regex.apply($cxx.sys_hdr_dirs, '(.+)', '-I\1')

    $moc --include $moc_predefs_path                    \
      $cc.poptions $cxx.poptions $dep_incl $sys_incl    \
      --output-dep-file --dep-file-path $t -o $o $s
  }}

  # Rule to run moc on an Objective-C++ source file (foo.mm -> foo.moc).
  #
  moc{~'/(.+)/'}: mm{~'/\1/'} libul{~'/.+Meta/'} $moc
  {{
    o = $path($>[0])
    t = $(o).t

    dep_incl = $cxx.lib_poptions($<[1])

    depdb hash $dep_incl

    depdb dyndep                                                \
      --byproduct --drop-cycles --what=header --default-type=h  \
      --update-exclude ($<[1])                                  \
      --file $t

    s = $path($<[0])

    sys_incl = $regex.apply($cxx.sys_hdr_dirs, '(.+)', '-I\1')

    $moc --include $moc_predefs_path                    \
      $cc.poptions $cxx.poptions $dep_incl $sys_incl    \
      --output-dep-file --dep-file-path $t -o $o $s
  }}

  # Define the Qt resource collection file type.
  #
  define qrc: file
  qrc{*}: extension = qrc

  import! [metadata] rcc = Qt6Rcc%exe{qt6rcc}

  # Rule to run rcc on a Qt resource collection file (foo.qrc -> qrc_foo.cpp).
  #
  cxx{~'/qrc_(.*)/'}: qrc{~'/.*\1/'} $rcc
  {{
    $rcc -name $name($<[0]) -o $path($>[0]) $path($<[0])
  }}

  # Define the QtWidgets user interface definition file type.
  #
  define ui: file
  ui{*}: extension = ui

  import! [metadata] uic = Qt6Uic%exe{qt6uic}

  # Rule to run uic on a QtWidgets user interface definition file (foo.ui ->
  # ui_foo.h).
  #
  hxx{~'/ui_(.*)/'}: ui{~'/.*\1/'} $uic
  {{
    $uic -o $path($>[0]) $path($<[0])
  }}

  if! $config.libQt6Widgets.debug
    cc.poptions += -DQT_NO_DEBUG

  # Every directory under mkspecs/ contains a unique `qplatformdefs.h`.
  #
  # Note that Mac OS with GCC is not supported by upstream (see README-DEV for
  # details).
  #
  switch $cxx.target.class, $cxx.id, $cxx.target.system
  {
    case 'linux', 'gcc'
      cc.poptions =+ "-I$src_root/mkspecs/linux-g++"
    case 'linux', 'clang'
      cc.poptions =+ "-I$src_root/mkspecs/linux-clang"
    case 'macos', 'clang-apple'
      cc.poptions =+ "-I$src_root/mkspecs/macx-clang"
    case 'bsd', 'clang', 'freebsd'
      cc.poptions =+ "-I$src_root/mkspecs/freebsd-clang"
    case 'bsd', 'gcc', 'openbsd'
      cc.poptions =+ "-I$src_root/mkspecs/openbsd-g++"
    case 'bsd', 'gcc', 'netbsd'
      cc.poptions =+ "-I$src_root/mkspecs/netbsd-g++"
    case 'windows', 'msvc'
      cc.poptions =+ "-I$src_root/mkspecs/win32-msvc"
    case 'windows', 'msvc-clang' | 'clang'
      cc.poptions =+ "-I$src_root/mkspecs/win32-clang-msvc"
    case 'windows', 'gcc', 'mingw32'
    {
      cc.poptions =+ "-I$src_root/mkspecs/win32-g++"
      cc.coptions += -fno-keep-inline-dllexport
    }
  }

  cc.poptions += -DQT_DEPRECATED_WARNINGS                                               \
                 -DQT_DEPRECATED_WARNINGS_SINCE=0x070000                                \
                 -DQT_DISABLE_DEPRECATED_BEFORE=($windows ? 0x040800 : 0x050000)        \
                 -DQT_LEAN_HEADERS=1                                                    \
                 -DQT_NO_JAVA_STYLE_ITERATORS                                           \
                 -DQT_NO_NARROWING_CONVERSIONS_IN_CONNECT

  # Disable exceptions.
  #
  switch $cxx.class
  {
    case 'gcc'
    {
      cxx.poptions += -DQT_NO_EXCEPTIONS
      cxx.coptions += -fno-exceptions
    }
    case 'msvc'
    {
      cxx.poptions += -DQT_NO_EXCEPTIONS
      cxx.coptions += /EHs- /EHc-
    }
  }

  if $windows
  {
    # Qt6 supports only Windows 10 and newer. Although the Qt headers do
    # define WINVER and _WIN32_WINNT (the minimum Windows version supported)
    # to 0x0A00 if they're undefined, mingw defines them to Windows 7 before
    # Qt can do it.
    #
    cc.poptions += -DWINVER=0x0A00 -D_WIN32_WINNT=0x0A00        \
                   -DUNICODE -D_UNICODE                         \
                   -DWIN32                                      \
                   -D_CRT_SECURE_NO_WARNINGS                    \
                   -D_USE_MATH_DEFINES

    if ($cxx.target.system == 'mingw32')
      cc.poptions += -DMINGW_HAS_SECURE_API=1
    else
      cc.poptions += -D_ENABLE_EXTENDED_ALIGNED_STORAGE
  }
  else
    cc.poptions += -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE

  # Don't install headers in mkspecs/ (which is at the root level and is shared
  # between QtWidgets/ and QtWidgetsPlugins/).
  #
  hxx{mkspecs/*}: install = false

  # Common options, etc., for all the plugins.
  #
  QtWidgetsPlugins/
  {
    if ($cxx.class == 'gcc')
      cxx.coptions += -fvisibility=hidden -fvisibility-inlines-hidden

    # Don't install any plugin headers (for static linking the API is presumably
    # declared by the Qt plugin infrastructure).
    #
    hxx{*}: install = false
  }
} # $build.mode != 'skeleton'
